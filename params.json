{"name":"ESP8266 Arduino core","tagline":"Programming ESP8266 with an Arduino IDE","body":"[![Linux build status](http://img.shields.io/travis/igrr/Arduino.svg)](https://travis-ci.org/igrr/Arduino)\r\n[![Donate](http://img.shields.io/paypal/donate.png?color=yellow)](https://www.paypal.com/webscr?cmd=_s-xclick&hosted_button_id=4M56YCWV6PX66)\r\n\r\nThis project brings support for ESP8266 chip to the Arduino environment. ESP8266WiFi library bundled with this project has the same interface as the WiFi Shield library, making it easy to re-use existing code and libraries.\r\n\r\n### Installing with Boards Manager ###\r\n\r\nStarting with 1.6.4, Arduino allows installation of third-party platform packages using Boards Manager. We have packages available for Windows, Mac OS, and Linux (32 and 64 bit).\r\n\r\n- Install Arduino 1.6.4 from the [Arduino website](http://www.arduino.cc/en/main/software).\r\n- Start Arduino and open Perferences window.\r\n- Enter ```http://arduino.esp8266.com/package_esp8266com_index.json``` into *Additional Board Manager URLs* field. You can add multiple URLs, separating them with commas.\r\n- Open Boards Manager from Tools > Board menu and install *esp8266* platform (and don't forget to select your ESP8266 board from Tools > Board menu after installation).\r\n\r\n### [Change log](hardware/esp8266com/esp8266/changes.md)\r\n\r\n### Building latest version from source ###\r\n```\r\n$ git clone https://github.com/esp8266/Arduino.git\r\n$ cd Arduino/build\r\n$ ant dist\r\n```\r\n\r\n### Supported boards ###\r\n- Generic esp8266 modules (without auto-reset support)\r\n- NodeMCU\r\n- Olimex MOD-WIFI-ESP8266\r\n\r\n### Things that work ###\r\n\r\n#### Basic Wiring functions ####\r\n\r\n```pinMode```, ```digitalRead```, ```digitalWrite```, ```analogWrite``` work as usual.\r\n\r\nPin numbers correspond directly to the esp8266 GPIO pin numbers. To read GPIO2,\r\ncall ```digitalRead(2);```\r\n\r\nGPIO0-GPIO15 can be ```INPUT```, ```OUTPUT```, ```INPUT_PULLUP```, and ```INPUT_PULLDOWN```.\r\nGPIO16 can be ```INPUT```, ```OUTPUT``` or ```INPUT_PULLDOWN```.\r\n\r\n```analogRead(A0)``` reads the value of the ADC channel connected to the TOUT pin.\r\n\r\n```analogWrite(pin, value)``` enables software PWM on the given pin. PWM may be used on pins 0 to 15.\r\nCall ```analogWrite(pin, 0)``` to disable PWM on the pin. ```value``` may be in range from 0 to ```PWMRANGE```, which is currently equal to 1023.\r\n\r\nPin interrupts are supported through ```attachInterrupt```, ```detachInterrupt``` functions.\r\nInterrupts may be attached to any GPIO pin, except GPIO16. Standard Arduino interrupt\r\ntypes are supported: ```CHANGE```, ```RISING```, ```FALLING```.\r\n\r\n#### Pin Functions ####\r\n\r\n![Pin Functions](https://raw.githubusercontent.com/Links2004/Arduino/esp8266/docs/pin_functions.png)\r\nThe most usable pin functions are mapped to the macro ```SPECIAL```, so calling ```pinMode(pin, SPECIAL)```\r\nwill switch that pin in the most usable FUNCTION_X. Those are UART RX/TX on pins 1 - 3, HSPI for pins 12-15 and CLK functions for pins 0, 4 and 5.\r\n\r\n#### Timing and delays ####\r\n```millis``` and ```micros``` return the number of milliseconds and microseconds elapsed after reset, respectively.\r\n\r\n```delay``` pauses the sketch for a given number of milliseconds and allows WiFi and TCP/IP tasks to run.\r\n```delayMicroseconds``` pauses for a given number of microseconds.\r\n\r\nRemember that there is a lot of code that needs to run on the chip besides the sketch\r\nwhen WiFi is connected. WiFi and TCP/IP libraries get a chance to handle any pending\r\nevents each time the ```loop()``` function completes, OR when ```delay(...)``` is called.\r\nIf you have a loop somewhere in your sketch that takes a lot of time (>50ms) without\r\ncalling ```delay()```, you might consider adding a call to delay function to keep the WiFi\r\nstack running smoothly.\r\n\r\nThere is also a ```yield()``` function which is equivalent to ```delay(0)```. The delayMicroseconds\r\nfunction, on the other hand, does not yield to other tasks, so using it for delays\r\nmore than 20 milliseconds is not recommended.\r\n\r\n#### Serial ####\r\n\r\n```Serial``` object works much the same way as on a regular Arduino. Apart from hardware FIFO (128 bytes for TX and RX) HardwareSerial has additional 256-byte TX and RX buffers. Both transmit and receive is interrupt-driven. Write and read functions only block the sketch execution when the respective FIFO/buffers are full/empty.\r\n\r\n```Serial``` uses UART0, which is mapped to pins GPIO1 (TX) and GPIO3 (RX). Serial may be remapped to GPIO15 (TX) and GPIO13 (RX) by calling ```Serial.swap();``` after ```Serial.begin();```. Calling ```swap``` again maps UART0 back to GPIO1 and GPIO3.\r\n\r\n```Serial1``` uses UART1 which is a transmit-only UART. UART1 TX pin is GPIO2. To use ```Serial1```, call ```Serial1.begin```.\r\n\r\nBy default the diagnostic output from WiFi libraries is disabled when you call ```Serial.begin```. To enable debug output again, call ```Serial.setDebugOutput(true);```. To redirect debug output to ```Serial1``` instead, call ```Serial1.setDebugOutput(true);```.\r\n\r\nYou also need to use ```Serial.setDebugOutput(true)``` to enable output from the Arduino ```printf()``` function.\r\n\r\nBoth ```Serial``` and ```Serial1``` objects support 5, 6, 7, 8 data bits, odd (O), even (E), and no (N) parity, and 1 or 2 stop bits. To set the desired mode, call ```Serial.begin(baudrate, SERIAL_8N1);```, ```Serial.begin(baudrate, SERIAL_6E2);```, etc.\r\n\r\n#### Progmem ####\r\n\r\nThe Program memory features work much the same way as on a regular Arduino; placing read only data and strings in read only memory and freeing heap for your application.\r\nThe important difference is that on the esp8266 the literal strings are not pooled.  This means that the same literal string defined inside a ```F(\"\")``` and/or ```PSTR(\"\")``` will take up space for each instance in the code. So you will need to manage the duplicate strings yourself.\r\n\r\n#### WiFi(ESP8266WiFi library) ####\r\n\r\nThis is mostly similar to WiFi shield library. Differences include:\r\n\r\n- ```WiFi.mode(m)```: set mode to ```WIFI_AP```, ```WIFI_STA```, or ```WIFI_AP_STA```.\r\n- call ```WiFi.softAP(ssid)``` to set up an open network\r\n- call ```WiFi.softAP(ssid, password)``` to set up a WPA2-PSK network (password should be at least 8 characters)\r\n- ```WiFi.macAddress(mac)``` is for STA, ```WiFi.softAPmacAddress(mac)``` is for AP.\r\n- ```WiFi.localIP()``` is for STA, ```WiFi.softAPIP()``` is for AP.\r\n- ```WiFi.RSSI()``` doesn't work\r\n- ```WiFi.printDiag(Serial);``` will print out some diagnostic info\r\n- ```WiFiUDP``` class supports sending and receiving multicast packets on STA interface.\r\nWhen sending a multicast packet, replace ```udp.beginPacket(addr, port)``` with\r\n```udp.beginPacketMulticast(addr, port, WiFi.localIP())```.\r\nWhen listening to multicast packets, replace ```udp.begin(port)``` with\r\n```udp.beginMulticast(WiFi.localIP(), multicast_ip_addr, port)```.\r\nYou can use ```udp.destinationIP()``` to tell whether the packet received was\r\nsent to the multicast or unicast address.\r\nAlso note that multicast doesn't work on softAP interface.\r\n\r\nWiFiServer, WiFiClient, and WiFiUDP behave mostly the same way as with WiFi shield library.\r\nFour samples are provided for this library.\r\nYou can see more commands here: [http://www.arduino.cc/en/Reference/WiFi](http://www.arduino.cc/en/Reference/WiFi)\r\n\r\n#### Ticker ####\r\n\r\nLibrary for calling functions repeatedly with a certain period. Two examples included.\r\n\r\nIt is currently not recommended to do blocking IO operations (network, serial, file) from Ticker\r\ncallback functions. Instead, set a flag inside the ticker callback and check for that flag inside the loop function.\r\n\r\n#### EEPROM ####\r\n\r\nThis is a bit different from standard EEPROM class. You need to call ```EEPROM.begin(size)```\r\nbefore you start reading or writing, size being the number of bytes you want to use.\r\nSize can be anywhere between 4 and 4096 bytes.\r\n\r\n```EEPROM.write``` does not write to flash immediately, instead you must call ```EEPROM.commit()```\r\nwhenever you wish to save changes to flash. ```EEPROM.end()``` will also commit, and will\r\nrelease the RAM copy of EEPROM contents.\r\n\r\nEEPROM library uses one sector of flash located at 0x7b000 for storage.\r\n\r\nThree examples included.\r\n\r\n#### I2C (Wire library) ####\r\n\r\nWire library currently supports master mode up to approximately 450KHz.\r\nBefore using I2C, pins for SDA and SCL need to be set by calling\r\n```Wire.begin(int sda, int scl)```, i.e. ```Wire.begin(0, 2);``` on ESP-01,\r\nelse they default to pins 4(SDA) and 5(SCL).\r\n\r\n#### SPI ####\r\n\r\nSPI library supports the entire Arduino SPI API including transactions, including setting phase (CPHA).\r\nSetting the Clock polarity (CPOL) is not supported, yet (SPI_MODE2 and SPI_MODE3 not working).\r\n\r\n#### ESP-specific APIs ####\r\n\r\nAPIs related to deep sleep and watchdog timer are available in the ```ESP``` object, only available in Alpha version.\r\n\r\n```ESP.deepSleep(microseconds, mode)``` will put the chip into deep sleep. ```mode``` is one of ```WAKE_RF_DEFAULT```, ```WAKE_RFCAL```, ```WAKE_NO_RFCAL```, ```WAKE_RF_DISABLED```. (GPIO16 needs to be tied to RST to wake from deepSleep.)\r\n\r\n```ESP.restart()``` restarts the CPU.\r\n\r\n```ESP.getFreeHeap()``` returns the free heap size.\r\n\r\n```ESP.getChipId()``` returns the ESP8266 chip ID as a 32-bit integer.\r\n\r\nSeveral APIs may be used to get flash chip info:\r\n\r\n```ESP.getFlashChipId()``` returns the flash chip ID as a 32-bit integer.\r\n\r\n```ESP.getFlashChipSize()``` returns the flash chip size, in bytes, as seen by the SDK (may be less than actual size).\r\n\r\n```ESP.getFlashChipSpeed(void)``` returns the flash chip frequency, in Hz.\r\n\r\n```ESP.getCycleCount()``` returns the cpu instruction cycle count since start as an unsigned 32-bit.  This is useful for accurate timing of very short actions like bit banging.\r\n\r\n```ESP.getVcc()``` may be used to measure supply voltage. ESP needs to reconfigure the ADC\r\nat startup in order for this feature to be available. Add the following line to the top\r\nof your sketch to use ```getVcc```:\r\n```\r\nADC_MODE(ADC_VCC);\r\n```\r\nTOUT pin has to be disconnected in this mode.\r\n\r\nNote that by default ADC is configured to read from TOUT pin using ```analogRead(A0)```, and\r\n```ESP.getVCC()``` is not available.\r\n\r\n#### OneWire (from https://www.pjrc.com/teensy/td_libs_OneWire.html) ####\r\n\r\nLibrary was adapted to work with ESP8266 by including register definitions into OneWire.h\r\nNote that if you already have OneWire library in your Arduino/libraries folder, it will be used\r\ninstead of the one that comes with this package.\r\n\r\n#### mDNS responder (ESP8266mDNS library) ####\r\n\r\nAllows the sketch to respond to multicast DNS queries for domain names like \"foo.local\".\r\nCurrently the library only works on STA interface, AP interface is not supported.\r\nSee attached example and library README file for details.\r\n\r\n#### DNS server (DNSServer library) ####\r\n\r\nImplements a simple DNS server that can be used in both STA and AP modes. The DNS server currently supports only one domain (for all other domains it will reply with NXDOMAIN or custom status code). With it clients can open a web server running on ESP8266 using a domain name, not an IP address.\r\nSee attached example for details.\r\n\r\n#### Servo ####\r\n\r\nThis library exposes the ability to control RC (hobby) servo motors. It will support upto 24 servos on any available output pin. By defualt the first 12 servos will use Timer0 and currently this will not interfere with any other support.  Servo counts above 12 will use Timer1 and features that use it will be effected.\r\nWhile many RC servo motors will accept the 3.3v IO data pin from a esp8266, most will not be able to run off 3.3v and will require another power source that matches their specifications.  Make sure to connect the grounds between the esp8266 and the servo motor power supply.\r\n\r\n#### Other libraries (not included with the IDE)\r\n\r\nLibraries that don't rely on low-level access to AVR registers should work well. Here are a few libraries that were verified to work:\r\n\r\n- [arduinoWebSockets](https://github.com/Links2004/arduinoWebSockets) - WebSocket Server and Client compatible with esp8266 (RFC6455)\r\n- [aREST](https://github.com/marcoschwartz/aREST) REST API handler library.\r\n- [Blynk](https://github.com/blynkkk/blynk-library) - easy IoT framework for Makers (check out the [Kickstarter page](http://tiny.cc/blynk-kick)).\r\n- [DallasTemperature](https://github.com/milesburton/Arduino-Temperature-Control-Library.git)\r\n- [DHT11](https://github.com/adafruit/DHT-sensor-library) - Download latest v1.1.0 library and no changes are necessary.  Older versions should initialize DHT as follows: ```DHT dht(DHTPIN, DHTTYPE, 15);```\r\n- [NeoPixel](https://github.com/adafruit/Adafruit_NeoPixel) - Adafruit's NeoPixel library, now with support for the ESP8266 (use version 1.0.2 or higher from Arduino's library manager).\r\n- [NeoPixelBus](https://github.com/Makuna/NeoPixelBus) - Arduino NeoPixel library compatible with esp8266. Use the \"NeoPixelAnimator\" branch for esp8266 to get HSL color support and more.\r\n- [PubSubClient](https://github.com/Imroy/pubsubclient) MQTT library by @Imroy.\r\n- [RTC](https://github.com/Makuna/Rtc) - Arduino Library for Ds1307 & Ds3231 compatible with esp8266.\r\n- [Souliss, Smart Home](https://github.com/souliss/souliss) - Framework for Smart Home based on Arduino, Android and openHAB.\r\n\r\n#### Upload via serial port ####\r\nPick the correct serial port.\r\nYou need to put ESP8266 into bootloader mode before uploading code.\r\n\r\n#### Power Supply ####\r\n\r\nFor stable use of the ESP8266 a power supply with 3V3 and >= 250mA is required.\r\n\r\n* Note\r\n - using Power from USB to Serial is may unstable, they not deliver enough current.\r\n\r\n#### Serial Adapter ####\r\n\r\nThere are many different USB to Serial adapters / boards.\r\n\r\n* Note\r\n - for full upload management you need RTS and DTR\r\n - the chip need to have 3V3 TTL (5V may damage the chip)\r\n - not all board have all pins of the ICs as breakout (check before order)\r\n - CTS and DSR are not useful for upload (they are Inputs)\r\n\r\n* Working ICs\r\n - FT232RL\r\n - CP2102\r\n - may others (drop a comment)\r\n\r\n#### Minimal hardware Setup for Bootloading and usage ####\r\n\r\nESPxx Hardware\r\n\r\n| PIN           | Resistor | Serial Adapter |\r\n| ------------- | -------- | -------------- |\r\n| VCC           |          | VCC (3.3V)     |\r\n| GND           |          | GND            |\r\n| TX or GPIO2*  |          | RX             |\r\n| RX            |          | TX             |\r\n| GPIO0         | PullUp   | DTR            |\r\n| Reset*        |          | RTS            |\r\n| GPIO15*       | PullDown |                |\r\n| CH_PD         | PullUp   |                |\r\n\r\n* Note\r\n - GPIO15 is also named MTDO\r\n - Reset is also named RSBT or REST (adding PullUp improves the stability of the Module)\r\n - GPIO2 is alternative TX for the boot loader mode\r\n\r\n###### esp to Serial\r\n![ESP to Serial](https://raw.githubusercontent.com/Links2004/Arduino/esp8266/docs/ESP_to_serial.png)\r\n\r\n#### Minimal hardware Setup for Bootloading only ####\r\nESPxx Hardware\r\n\r\n| PIN           | Resistor | Serial Adapter  |\r\n| ------------- | -------- | --------------- |\r\n| VCC           |          | VCC (3.3V)      |\r\n| GND           |          | GND             |\r\n| TX or GPIO2   |          | RX              |\r\n| RX            |          | TX              |\r\n| GPIO0         |          | GND             |\r\n| Reset         |          | RTS*            |\r\n| GPIO15        | PullDown |                 |\r\n| CH_PD         | PullUp   |                 |\r\n\r\n* Note\r\n\t- if no RTS is used a manual power toggle is needed\r\n\r\n#### Minimal hardware Setup for running only ####\r\n\r\nESPxx Hardware\r\n\r\n| PIN           | Resistor | Power supply    |\r\n| ------------- | -------- | --------------- |\r\n| VCC           |          | VCC (3.3V)      |\r\n| GND           |          | GND             |\r\n| GPIO0         | PullUp   |                 |\r\n| GPIO15        | PullDown |                 |\r\n| CH_PD         | PullUp   |                 |\r\n\r\n###### minimal\r\n![ESP min](https://raw.githubusercontent.com/Links2004/Arduino/esp8266/docs/ESP_min.png)\r\n\r\n###### improved stability\r\n![ESP improved stability](https://raw.githubusercontent.com/Links2004/Arduino/esp8266/docs/ESP_improved_stability.png)\r\n\r\n### Issues and support ###\r\n\r\nForum: http://www.esp8266.com/arduino\r\n\r\nSubmit issues on Github: https://github.com/esp8266/Arduino/issues\r\n\r\n### License and credits ###\r\n\r\nArduino IDE is based on Wiring and Processing. It is developed and maintained by the Arduino team. The IDE is licensed under GPL, and the core libraries are licensed under LGPL.\r\n\r\nThis build includes an xtensa gcc toolchain, which is also under GPL.\r\n\r\nEspressif SDK included in this build is under Espressif Public License.\r\n\r\nEsptool written by Christian Klippel is licensed under GPLv2, currently maintained by Ivan Grokhotkov: https://github.com/igrr/esptool-ck.\r\n\r\nESP8266 core support, ESP8266WiFi, Ticker, ESP8266WebServer libraries were written by Ivan Grokhotkov, ivan@esp8266.com.\r\n\r\n[SPI Flash File System (SPIFFS)](https://github.com/pellepl/spiffs) written by Peter Andersson is used in this project. It is distributed under MIT license.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}